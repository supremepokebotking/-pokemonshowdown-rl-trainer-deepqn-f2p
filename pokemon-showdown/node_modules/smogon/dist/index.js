"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Statistics = exports.Analyses = void 0;
const latest = Promise.resolve().then(() => __importStar(require('./latest.json')));
const LATEST = latest;
const GENS = ['rb', 'gs', 'rs', 'dp', 'bw', 'xy', 'sm', 'ss'];
const PARSE_REGEX = /dexSettings = ({.*})/;
function toID(text) {
    return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '');
}
exports.Analyses = new (class {
    constructor() {
        this.URL = 'https://www.smogon.com/dex/';
        this.RPC = '_rpc/dump-pokemon';
    }
    /**
     * Returns the Analysis URL for a given pokemon and gen.
     * @deprecated use Analyses.request
     */
    url(pokemon, gen = 8) {
        return `${exports.Analyses.URL}${exports.Analyses.gen(gen)}/pokemon/${toID(pokemon)}/`;
    }
    /**
     * Returns the Analysis RPC URL and request configuration for a given pokemon and gen.
     */
    request(pokemon, gen = 8) {
        return {
            url: `${exports.Analyses.URL}${exports.Analyses.RPC}`,
            init: {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                },
                body: JSON.stringify({ gen: exports.Analyses.gen(gen), alias: toID(pokemon) }),
            },
        };
    }
    /**
     * Parses out the DexSettings object embedded in the raw HTML retrieved from the Smogon dex.
     */
    parse(raw) {
        const match = PARSE_REGEX.exec(raw);
        if (!match)
            return undefined;
        return JSON.parse(match[1]);
    }
    /**
     * Given either the raw HTML retrieved from the Smogon dex, the parsed DexSettings object, or
     * an RPC response, returns a map of Analysis objects keyed by format or undefined if its input
     * was invalid.
     */
    process(ds) {
        var _a, _b;
        const parsed = typeof ds === 'string' ? exports.Analyses.parse(ds) : ds;
        if (!parsed)
            return undefined;
        let strategies;
        if ('injectRpcs' in parsed) {
            const valid = (_b = (_a = parsed.injectRpcs[2]) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b['strategies'];
            if (!valid)
                return undefined;
            strategies = valid;
        }
        else {
            strategies = parsed.strategies;
        }
        const analysesByFormat = new Map();
        for (const analysis of strategies) {
            let analyses = analysesByFormat.get(analysis.format);
            if (!analyses) {
                analyses = [];
                analysesByFormat.set(analysis.format, analyses);
            }
            analyses.push(analysis);
        }
        return analysesByFormat;
    }
    /**
     * Returns Smogon's display representation of the given gen.
     */
    gen(gen) {
        return GENS[gen - 1];
    }
})();
// Metagames which continued to be played after gen6, transitioning from a bare unqualified
// name to a 'gen6'-qualified one. Most migrated over on 2017-07, though the LATE metagames
// below were only given qualification from 2018 and onward.
const LEGACY = new Set([
    '1v1', 'anythinggoes', 'battlespotdoubles', 'battlespotsingles', 'battlespottriples',
    'cap', 'lc', 'monotype', 'nu', 'ou', 'pu', 'randombattle', 'ru', 'ubers', 'uu',
    'balancedhackmons', 'doublesou', 'doublesuu', 'battlefactory', 'mixandmega', 'vgc2016',
    'ounoteampreview', 'customgame', 'doublescustomgame', 'triplescustomgame', 'purehackmons',
    'almostanyability',
]);
exports.Statistics = new (class {
    constructor() {
        this.URL = 'https://www.smogon.com/stats/';
    }
    /**
     * Given the HTML page returned from querying the Statistics.URL, returns the most recent
     * date stats are available for. This should usually be the beginning of the current month,
     * but this approach is more robust due to timezone differences and delays in publishing.
     */
    latest(page) {
        const lines = page.split('\n');
        let i = lines.length;
        while (i--) {
            const line = lines[i];
            if (line.startsWith('<a href=')) {
                return line.slice(9, 16);
            }
        }
        throw new Error('Unexpected format for index');
    }
    /**
     * Returns the URL of the detailed ('chaos') stats for the given date and format, defaulting
     * to providing the highest weighted stats available for the format in question. Unweighted
     * stats or stats of a specific weight may also be requested, though may be absent depending
     * on the date and format.
     */
    url(date, format, weighted = true) {
        let formatid = toID(format);
        // When Gen 7 was released the naming scheme for 'current' formats was changed from
        // 'x' => 'genNx'. formatFor will translate between the two as approriate, but there
        // is an edge case for 2016-12 where both randombattle and gen6randombattle exist
        if (!(date === '2016-12' && ['gen6randombattle', 'randombattle'].includes(formatid))) {
            formatid = formatFor(formatid, date);
        }
        // If we've been given a weight then we use that, otherwise we use weightFor to
        // figure out what the highest weight cutoff for the format was (usually 1630 or 1695)
        const rating = weighted
            ? typeof weighted === 'number' ? weighted
                : weightFor(formatid, date)
            : 0;
        return `${exports.Statistics.URL}${date}/chaos/${formatid}-${rating}.json`;
    }
    /**
     * Returns the date and count of the latest stats available for the given format at the time
     * this package was published. If best is provided, it will return the date and count for the
     * most recent month where a substantial enough amount of data was gathered. Returns undefined
     * if there is no data present. Note the accuracy of this function depends on the data in
     * latest.json being kept up to date.
     */
    async latestDate(format, best = false) {
        format = exports.Statistics.canonicalize(toID(format));
        const data = (await LATEST)[format];
        if (!data)
            return undefined;
        const [date, count] = (Array.isArray(data[0]) ? data[+best] : data);
        return { date, count };
    }
    /**
     * Returns the canconical format name for the given format.
     */
    canonicalize(format) {
        return LEGACY.has(format) ? `gen6${format}` : format;
    }
    /**
     * Processes what was fetched from the URL returned by Statistics.url into UsageStatistics.
     */
    process(raw) {
        return JSON.parse(raw);
    }
})();
const POPULAR = [
    'gen8ou', 'gen8doublesou', 'gen7ou', 'gen7doublesou',
    'ou', 'doublesou', 'smogondoubles', 'randombattle',
];
// TODO: add a discontinuity for gen7{ou,doublesou}?
function weightFor(format, date) {
    // gen7ou is no longer the main gen
    if (format === 'gen7ou' && date > '2020-01')
        return 1630;
    // gen7doublesu ou and smogondoublessuspecttest have used different weights over the years
    if (format === 'gen7doublesou' && (date < '2017-02' || date > '2020-01'))
        return 1630;
    if (format === 'smogondoublessuspecttest' && date === '2015-04')
        return 1695;
    // Otherwise, formats deemed 'popular' are assigned higher weight. Note that legacy format
    // notation is signficant here: gen6ou was only 'popular' while it was still called 'ou'
    return POPULAR.includes(format) ? 1695 : 1630;
}
const LATE = ['1v1', 'cap', 'monotype', 'balancedhackmons', 'mixandmega'];
const FORMAT_REGEX = /gen(\d)(.*)/;
function formatFor(format, date) {
    // 2017-01/02 mark the last random battle statistics, at which point randombattle has been
    // renamed to its qualified form several months before the other formats
    if (['gen6randombattle', 'randombattle'].includes(format) && date > '2016-12') {
        return 'gen6randombattle';
    }
    const m = FORMAT_REGEX.exec(format);
    // Return if we've been given a format with the standard notation and its not Gen 6
    if (m && m[1] !== '6')
        return format;
    // Return the unqualified metagame if the format starts with 'gen6' but has been discontinued
    if (m && !LEGACY.has(m[2]))
        return m[2];
    if (m) {
        // If the format is 'gen6'-qualified but the date requested is before the standard 2017-06/07
        // migration (or was a late-migrating metagame and before 2017-12/2018-01), remove the qualifier
        return date < '2017-07' || (date < '2018-01' && LATE.includes(m[2])) ? m[2] : format;
    }
    else {
        // If the format unqualified but the date requested is after the standard 2017-06/07 migration
        // (or was a late-migrating metagame and after 2017-12/2018-01), add the 'gen6'-qualifier
        return date > '2017-12' || (date > '2017-06' && !LATE.includes(format))
            ? `gen6${format}`
            : format;
    }
}
//# sourceMappingURL=index.js.map